from functools import cached_property
from time import time
import warnings
from irrep.bandstructure import BandStructure
from irrep.spacegroup import SpaceGroupBare
import numpy as np

from ..wannierise.projections import ProjectionsSet

from ..w90files import DMN
from .Dwann import Dwann


class SymmetrizerDMN(DMN):
    """
    An extended class for DMN object, which cannot be written to a w90 file, because it 
    contains more information than can be stored in the wannier90.dmn file
    Now the wannierisation in wannier-berri is NOT compatible with the format of the wannier90.dmn file,
    Thus the name "dmn" is kept for historical reasons, but the class is not compatible with the wannier90.dmn file
    """

    def __init__(self, seedname="wannier90", num_wann=None, num_bands=None, nkpt=None,
                 empty=False,
                 **kwargs):
        self.npz_tags = ['D_wann_block_indices', '_NB',
                    'kpt2kptirr', 'kptirr', 'kptirr2kpt', 'kpt2kptirr_sym',
                   '_NK', 'num_wann', 'comment', 'NKirr', 'Nsym', 'time_reversals']

        if empty:
            self._NB = 0
            self.num_wann = 0
            self.D_wann_block_indices = np.zeros((0, 2), dtype=int)
            self.NKirr = 0
            self.Nsym = 0
            self.kpoints = np.zeros((0, 3), dtype=float)
            self.kpt2kptirr = np.zeros(0, dtype=int)
            self.kptirr = np.zeros(0, dtype=int)
            self.kptirr2kpt = np.zeros((0, 0), dtype=int)
            return
        if seedname is None:
            self.set_identiy(num_wann, num_bands, nkpt)
            return
        super().__init__(seedname, "dmn", **kwargs)



    def from_irrep(self, bandstructure: BandStructure,
                 grid=None, degen_thresh=1e-2):
        """
        Initialize the object from the BandStructure object

        Parameters
        ----------
        bandstructure : irrep.bandstructure.BandStructure
            the object containing the band structure
        grid : tuple(int), optional
            the grid of kpoints (3 integers), if None, the grid is determined from the kpoints
            may be used to reduce the grid (by an integer factor) for the symmetry analysis
        degen_thresh : float, optional
            the threshold for the degeneracy of the bands. Only transformations between bands
             with energy difference smaller than this value are considered
        """
        data = bandstructure.get_dmn(grid=grid, degen_thresh=degen_thresh, unitary=True)
        self.grid = data["grid"]
        self.kpoints = data["kpoints"]
        self.kpt2kptirr = data["kpt2kptirr"]
        self.kptirr = data["kptirr"]
        self.kptirr2kpt = data["kptirr2kpt"]
        self.d_band_blocks = data["d_band_blocks"]
        self.d_band_block_indices = data["d_band_block_indices"]

        self.comment = "Generated by wannierberri with irrep"
        self.D_wann = []
        self.spacegroup = bandstructure.spacegroup
        self.Nsym = bandstructure.spacegroup.size
        self.time_reversals = np.array([symop.time_reversal for symop in self.spacegroup.symmetries])
        self.NKirr = len(self.kptirr)
        self._NK = len(self.kpoints)
        self._NB = bandstructure.num_bands
        self.clear_inverse()


    def set_D_wann_from_projections(self,
                                    projections=None,
                                    projections_obj=None,
                                    kpoints=None):
        """
        Parameters
        ----------
        projections : list( (np.array(float, shape=(3,)), str) )
            the list of projections. Each projection is a tuple of the position and the orbital name. e.g [(np.array([0, 0, 0]), "s"), (np.array([0, 0.5, 0.5]), "p")]
        projections_obj : ProjectionsSet or list(Projection)
            alternative way to provide the projections. Will be appended to the projections list
        kpoints : np.array(float, shape=(npoints,3,))
            the kpoints in fractional coordinates (neede only if the kpoints are not stored in the object yet) 
        """
        from .sym_wann_orbitals import Orbitals
        if projections is None:
            projections = []
        ORBITALS = Orbitals()
        if not hasattr(self, "kpoints") or self.kpoints is None:
            if kpoints is None:
                warnings.warn("kpoints are not provided, neither stored in the object. Assuming Gamma point only")
                kpoints = np.array([[0, 0, 0]])
            self.kpoints = kpoints
            self._NK = len(kpoints)

        if projections_obj is not None:
            if isinstance(projections_obj, ProjectionsSet):
                projections_obj = projections_obj.projections
            for proj in projections_obj:
                orbitals = proj.orbitals
                print(f"orbitals = {orbitals}")
                if len(orbitals) > 1:
                    warnings.warn(f"projection {proj} has more than one orbital. it will be split into separate blocks, please order them in the win file consistently")
                for orb in orbitals:
                    projections.append((proj.positions, orb))

        D_wann_list = []
        self.T_list = []
        self.atommap_list = []
        self.rot_orb_list = []
        for positions, proj in projections:
            print(f"calculating Wannier functions for {proj} at {positions}")
            _Dwann = Dwann(self.spacegroup, positions, proj, ORBITALS=ORBITALS, spinor=self.spacegroup.spinor)
            _dwann = _Dwann.get_on_points_all(self.kpoints, self.kptirr, self.kptirr2kpt)
            D_wann_list.append(_dwann)
            self.T_list.append(_Dwann.T)
            self.atommap_list.append(_Dwann.atommap)
            self.rot_orb_list.append(_Dwann.rot_orb)
        print(f"len(D_wann_list) = {len(D_wann_list)}")
        self.set_D_wann(D_wann_list)

    @cached_property
    def rot_orb_dagger_list(self):
        return [rot_orb.swapaxes(1, 2).conj()
            for rot_orb in self.rot_orb_list]


    def symmetrize_smth(self, wannier_property):
        ncart = (wannier_property.ndim - 1)
        if ncart == 0:
            wcc_red_in = wannier_property
        elif ncart == 1:
            wcc_red_in = wannier_property @ self.spacegroup.lattice_inv
        else:
            raise ValueError("The input should be either a vector or a matrix")
        WCC_red_out = np.zeros((self.num_wann,) + (3,) * ncart, dtype=float)
        for isym, symop in enumerate(self.spacegroup.symmetries):
            for block, (ws, _) in enumerate(self.D_wann_block_indices):
                norb = self.rot_orb_list[block][0].shape[0]
                T = self.T_list[block][:, isym]
                num_points = T.shape[0]
                atom_map = self.atommap_list[block][:, isym]
                for atom_a in range(num_points):
                    start_a = ws + atom_a * norb
                    atom_b = atom_map[atom_a]
                    start_b = ws + atom_b * norb
                    XX_L = wcc_red_in[start_a:start_a + norb]
                    if ncart > 0:
                        XX_L = symop.transform_r(XX_L) + T[atom_a]
                    # XX_L = symop.transform_r(wcc_red_in[start_a:start_a + norb]) + T[atom_a]
                    # NOTE : I do not fully understand why the transpose are needed here but it works TODO  : check
                    transformed = np.einsum("ij,j...,ji->i...", self.rot_orb_dagger_list[block][isym].T, XX_L, self.rot_orb_list[block][isym].T).real
                    WCC_red_out[start_b:start_b + norb] += transformed
        if ncart > 0:
            WCC_red_out = WCC_red_out @ self.spacegroup.lattice
        return WCC_red_out / self.spacegroup.size

    def symmetrize_WCC(self, wannier_centers_cart):
        return self.symmetrize_smth(wannier_centers_cart)

    def symmetrize_spreads(self, wannier_spreads):
        return self.symmetrize_smth(wannier_spreads)

    def set_spacegroup(self, spacegroup):
        self.spacegroup = spacegroup
        self.time_reversals = np.array([symop.time_reversal for symop in self.spacegroup.symmetries])
        self.Nsym = spacegroup.size

    def as_dict(self):
        dic = super().as_dict()
        if hasattr(self, "spacegroup"):
            for k, val in self.spacegroup.as_dict().items():
                dic["spacegroup_" + k] = val
        for attrname in ["T", "atommap", "rot_orb"]:
            if hasattr(self, attrname + "_list"):
                for i, t in enumerate(self.__getattribute__(attrname + "_list")):
                    dic[f'{attrname}_{i}'] = t
        return dic


    def from_dict(self, dic):
        t0 = time()
        super().from_dict(dic)
        t1 = time()
        prefix = "spacegroup_"
        l = len(prefix)
        dic_spacegroup = {k[l:]: v for k, v in dic.items() if k.startswith(prefix)}
        if len(dic_spacegroup) > 0:
            self.spacegroup = SpaceGroupBare(**dic_spacegroup)
        t2 = time()
        for prefix in ["T", "atommap", "rot_orb"]:
            keys = sorted([k for k in dic.keys() if k.startswith(prefix)])
            lst = [dic[k] for k in keys]
            self.__setattr__(prefix + "_list", lst)
        t3 = time()
        print(f"time for read_npz dmn {t3-t0}\n super {t1-t0} \n spacegroup {t2-t1}\n  T {t3-t2} ")


class SymmetrizerDMNvoid(SymmetrizerDMN):

    def __init__(self, *args, **kwargs):
        pass

    def symmetrize_smth(self, wannier_property):
        return wannier_property
