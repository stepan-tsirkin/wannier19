#                                                            #
# This file is distributed as part of the WannierBerri code  #
# under the terms of the GNU General Public License. See the #
# file `LICENSE' in the root directory of the WannierBerri   #
# distribution, or http://www.gnu.org/copyleft/gpl.txt       #
#                                                            #
# The WannierBerri code is hosted on GitHub:                 #
# https://github.com/stepan-tsirkin/wannier-berri            #
#                     written by                             #
#           Stepan Tsirkin, University of Zurich             #
#   some parts of this file are originate                    #
# from the translation of Wannier90 code                     #
#------------------------------------------------------------#

import numpy as np
import multiprocessing
from .__utility import real_recip_lattice
from .__system_w90 import System_w90
from termcolor import cprint

np.set_printoptions(precision=4, threshold=np.inf, linewidth=500)


class System_ASE(System_w90):
    """
    System initialized from the Wannier functions generated by `ASE <https://wiki.fysik.dtu.dk/ase/_modules/ase/dft/wannier.html>`__ .

    Parameters
    ----------
    ase_wannier :
        An object of  `ASE Wannier <https://wiki.fysik.dtu.dk/ase/_modules/ase/dft/wannier.html#Wannier>`__ .
    ase_calc : ASE calculator (GPAW)
        needed only when `berry=True`
    transl_inv : bool
        Use Eq.(31) of `Marzari&Vanderbilt PRB 56, 12847 (1997) <https://journals.aps.org/prb/abstract/10.1103/PhysRevB.56.12847>`_ for band-diagonal position matrix elements
    npar : int
        number of processes used in the constructor
    fft : str
        library used to perform the fast Fourier transform from **q** to **R**. ``fftw`` or ``numpy``. (practically does not affect performance,
        anyway mostly time of the constructor is consumed by reading the input files)

    Notes
    -----
    see also  parameters of the :class:`~wannierberri.System`
    """
    def __init__(
                self,
                ase_wannier,
                ase_calc=None,
                transl_inv=True,
                fft='fftw',
                ase_R_vectors=False,  # for testing vs ASE
                npar=multiprocessing.cpu_count(),
                **parameters):
        self.set_parameters(**parameters)
        self.seedname = "ASE"
        ase_wannier.translate_all_to_cell()
        self.real_lattice, self.recip_lattice = real_recip_lattice(real_lattice=np.array(ase_wannier.unitcell_cc))
        self.mp_grid = ase_wannier.kptgrid

        if not ase_R_vectors:
            self.iRvec, self.Ndegen = self.wigner_seitz(self.mp_grid)
        else:  # enable to do ase-like R-vectors
            N1, N2, N3 = (self.mp_grid - 1) // 2
            self.iRvec = np.array(
                [[n1, n2, n3] for n1 in range(-N1, N1 + 1) for n2 in range(-N2, N2 + 1) for n3 in range(-N3, N3 + 1)],
                dtype=int)
            self.Ndegen = np.ones(self.iRvec.shape[0], dtype=int)

        for i, R in enumerate(self.iRvec):
            if np.all(R == [0, 0, 0]):
                self.iRvec0 = i
                break

        self.nRvec0 = len(self.iRvec)
        self.num_wann = ase_wannier.nwannier
        self.num_kpts = ase_wannier.Nk
        self.wannier_centers_cart_auto = ase_wannier.get_centers()
        print(f"got the Wanier centers : {self.wannier_centers_cart_auto}")
        #  a minus sign to account for a weird Bloch phase convention of ase.dft.Wannier module
        self.kpt_red = ase_wannier.kpt_kc

        kpt_mp_grid = [
            tuple(k)
            for k in np.array(np.round(self.kpt_red * np.array(self.mp_grid)[None, :]), dtype=int) % self.mp_grid
        ]
        if (0, 0, 0) not in kpt_mp_grid:
            raise ValueError(
                "the grid of k-points read from .chk file is not Gamma-centerred. Please, use Gamma-centered grids in the ab initio calculation"
            )

        self.Ham_R = np.array([ase_wannier.get_hopping(R) / nd for R, nd in zip(self.iRvec, self.Ndegen)]).transpose(
            (1, 2, 0))

        self.getXX_wan_cent()

        self.do_at_end_of_init()

        cprint("Reading the ASE system finished successfully", 'green', attrs=['bold'])

    def get_AA_q(self, mmn, wannier, transl_inv=False):  # if eig is present - it is BB_q
        #        if transl_inv and (eig is not None):
        #           raise RuntimeError("transl_inv cannot be used to obtain BB")
        AA_q = np.zeros((self.num_kpts, self.num_wann, self.num_wann, 3), dtype=complex)
        AAW = np.zeros((self.num_wann, self.num_wann, 3), dtype=complex)
        for ik in range(self.num_kpts):
            for ib in range(mmn.NNB):
                data = mmn.data[ik, ib]
                AAW = (wannier.V_knw[ik]).T.conj().dot(data.dot(wannier.V_knw[mmn.neighbours[ik, ib]]))
                AA_q_ik = 1.j * AAW[:, :, None] * mmn.wk[ib] * mmn.bk_cart[ib, None, None, :]
                if transl_inv:
                    AA_q_ik[range(self.num_wann),
                            range(self.num_wann
                                  )] = -np.log(AAW.diagonal()).imag[:, None] * mmn.wk[ib] * mmn.bk_cart[ib, None, :]
                AA_q[ik] += AA_q_ik


#        if eig is None:
#        AA_q=0.5*(AA_q+AA_q.transpose( (0,2,1,3) ).conj())
        return AA_q


