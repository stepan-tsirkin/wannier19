This example was elaborated on the basis of example18 of Wannier90

This example demonstrates calculation of AHC wuth wannier19, and compares the results and performance with postw90

wannier19 can read the the data of the system from two sources:

1) the 'Fe_tb.dat' file, generated by wannier90

2) the files 'Fe_AA_R.dat', 'Fe_HH_R.dat', 'Fe_HH_save.info', whic can be writeen by postw90.x , if it was compiled from the following branch: https://github.com/stepan-tsirkin/wannier90/tree/saveHH


The example can be run by simply 

> bash ./run.sh

and one can compare results.  One can see, that the second option  gives exactly the same results, as postw90.x the results from the first option are slightly diferent (however within accuracy),  which is probably caused, that the _tb file is written by a different piece of code, then the AA_ matrices.

In any case, 
For a single Efermi wannier19 works 5 time faster, and I expect that the advantage will grow with the size of ab-initio mesh (not tested yet)
For fermi-scan mode the advantage is less (because Fourier transform does not take majority of time anymore), but still a factor of 2

wannier19 can be run in parallel, just change the following line in python script:
     AHC=eval_integral_BZ(eval_func,Data,NKdiv,NKFFT=NKFFT,parallel=True,nproc=4)

for wannier19 one operates with to grids of k-points:

1)the FFT grid
2)the grid of shifts of k-points

the resulting integration grid will be the product of the two.  parallelization is done over the shift-grid
large FFT grid imposes larger memory requirements. 

I beleive, that optimal performance is achieved when FFT grid is slightly larger then the abinitio grid,  further refinement should be achieved by refining shift-grid.

AHC can also be calcualted for any tight-binding model, for which a '*_tb.dat' file was generated in watever way.

